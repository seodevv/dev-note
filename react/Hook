---------------------------------------------------------------------------
useState
// 컴포넌트의 state(상태)를 관리 할 수 있다.
// state 변경될 경우 해당 state 를 사용하는 컴포넌트가 자동으로 재랜더링된다.

import { useState } from 'react';
const [state, setState] = useState<type>(initialValue);
const [isLoggedIn, setIsLoggedIn] = useState<boolean>(false);



---------------------------------------------------------------------------
useEffect
// 랜더링 이후에 실행할 코드를 만들 수 있다.
// 어떤 변수가 변경될 때마다(의존성) 특정 기능이 동작하도록 할 수 있다.
// return 안의 코드가 먼저 실행되고 콜백 함수 안의 내용이 다음으로 실행된다.
// useLayoutEffect 와의 차이점은 useEffect 는 비동기 방식으로 처리된다.

import { useEffect } from 'react';
const [data, setData] = useState<boolean>(false);

useEffect( () => {
  console.log("useEffect(callback): Run second");
  return () => {
    console.log("useEffect(return): Run first");
  }
}, [data] );

// 최초 랜더링될 땐 return 안의 코드는 생략된다.
// 재랜더링할 경우 return 안의 코드가 먼저 실행된 후, callback 안의 코드가 실행된다.



---------------------------------------------------------------------------
useLayoutEffect
// 모든 DOM 변경 후 브라우저가 화면을 그리기(render) 전에 실행되는 기능을 정할 수 있다.
// useEffect 와의 차이점은 useLayoutEffect 는 동기 방식으로 처리된다.

import { useLayoutEffect } from 'react';
const [data, setData] = useState<boolean>(false);

useLayoutEffect( () => {
  console.log("useLayoutEffect(callback): Run second");
  return () => {
    console.log("useLayoutEffect(return): Run first");
  }
}, [data]);

// 최초 랜더링될 땐 return 안의 코드는 생략된다.
// 재랜더링할 경우 return 안의 코드가 먼저 실행된 후, callback 안의 코드가 실행된다.



---------------------------------------------------------------------------
useCallback<type>(callback, [dependency])
// 의존성 배열에 적힌 값이 변할 때만, 함수를 다시 정의할 수 있다.
// 의존성 배열에 적힌 값이 없을 경우, 컴포넌트가 재랜더링될 때 함수가 다시 정의된다.



---------------------------------------------------------------------------
useMemo<type>(callback, [dependency])
// 의존성 배열에 적힌 값이 변할 때만, 함수를 다시 정의할 수 있다.
// 의존성 배열에 적힌 값이 없을 경우, 컴포넌트가 재랜더링될 때 함수가 다시 정의된다.



---------------------------------------------------------------------------
useRef<type>
// 컴포넌트나 HTML 요소를 래퍼런스로 관리할 수 있다.



---------------------------------------------------------------------------
forwardRef
// useRef 로 만든 래퍼런스를 상위 컴포넌트로 전달할 수 있다.



---------------------------------------------------------------------------
useReducer
// state(상태) 업데이트 로직을, reducer 함수에 따로 분리할 수 있다.



---------------------------------------------------------------------------
useContext
// 부모 컴포넌트와 자식 컴포넌트 간의 변수와 함수를 전역적으로 정의할 수 있다.

# 1
# ./src/context/newContext.ts
# 컨텍스트 생성 및 변수를 생성하는 곳
import { createContext } from 'react';

type Products = {
  id: number,
  title: string,
}[];

const products:Products = [
  { id: 0, title: 'shoes' },
  { id: 1, title: 'shirt' },
  { id: 2, title: 'jacket' },
]

const newContext = createContext(products);
// 전역으로 사용할 변수를 초기화하고 createContext 를 통해 컨텍스트를 생성한다.

export { newContext products };
export type { Products };
// 사용할 컨텍스트와 초기화된 변수를 export 해준다.


# 2
# ./src/App.tsx
# 자식 컴포넌트들에게 컨텍스트를 제공해준다.
import { Routes, Route } from 'react-router-dom';
import { newContext, products } from './context/newContext';
import Home from './components/Home';

function App() {
  const item = products;
  // 컨텍스트에서 초기화한 변수를 가져온다.
  return (
    <>
      <newContext.Provider value={item}>
      // 초기화한 변수를 자식 컴포넌트에게 제공한다.
        <Routes>
          <Route path="/" element={<Home/>}/>
        </Routes>
      </newContext.Provider>
    </>
  )
}
export default App;


# 3
# ./src/components/Home.tsx
# 컨텍스트로 받은 변수를 사용한다.
import { useContext } from 'react';
import { newContext } from '../Context/newContext';

function Home(){
  const item = useContext(newContext);
  // 컨텍스트 변수를 useContext 를 활용해 불러온다.
  return (
    <>
      <div className="container">
        <ul>
          { item.map( v => (<li key={v.id}>{v.title}</li>) );
        </ul>
        // 컨텍스트 변수를 활용해 ReactNode 를 작성한다.
      </div>
    </>
  )
}
export default Home;



---------------------------------------------------------------------------
useDebugValue
// 사용자 정의 Hook 의 디버깅을 도와준다.
